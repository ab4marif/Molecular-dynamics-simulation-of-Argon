import numpy as np
from matplotlib import pyplot as plt
from matplotlib import animation




def createCoordinate(Numberparticles, Dimension):
    return np.random.random((Numberparticles,Dimension))*L

def createVelocity(Numberparticles, Dimension):
    return np.random.random((Numberparticles,Dimension))

def calculateDistance(r):
    N = r.shape[0]
    D = r.shape[1]
        
    bigR = np.broadcast_to(r, (N, N, D))
    bigRT = np.transpose(bigR, (1, 0, 2))
    
    deltaR = bigR - bigRT
    
    # minimal image implementation
    deltaR = (deltaR + L/2)%L - L/2
    
    return deltaR

def calculateForce(r, eps, sigma):
    deltaR = calculateDistance(r)
    
    normR = np.linalg.norm(deltaR, axis = 2, keepdims = True)
    mask = np.eye(N, dtype = bool)
    normR[mask,:] = 1
    
    
    deltaU = 4*eps*(6*sigma**6/normR**8 - 12*sigma**12/normR**14)*deltaR
    F = -np.sum(deltaU, axis = 1 )
    
    return F

def eulerMethod(r, v):
    F = calculateForce(r, eps, sigma)
    v = v + 1/mass*F*dt
    r = r + v*dt
    
    # boundary
    r = r%L
    return r, v



dt = 3e-11
eps = 119.8*1.38*10**-23
sigma = 3.405E-10
mass = 6.6E-26 
N = 5
D = 2
L = 2e-9
Timesteps = 100 #timesteps

r = np.zeros((N, D, Timesteps))
r[:,:,0] = createCoordinate(N, D)
v = createVelocity(N,D)*0
F = calculateForce(r[:,:,0], eps, sigma)


for i in range(1,Timesteps):
    r[:,:,i], v = eulerMethod(r[:,:,i-1] , v)
    
plt.plot(r[0,0,:], r[0,1,:], 'ro')
plt.plot(r[1,0,:], r[1,1,:], 'bo')



##################################################################################################################
############################ Animation ###########################################################################


# First set up the figure, the axis, and the plot element we want to animate
fig = plt.figure()
ax = plt.axes(xlim=(0, L), ylim=(0, L))
line, = ax.plot([], [], 'o', lw=2)

# initialization function: plot the background of each frame
def init():
    line.set_data([], [])
    return line,

# animation function.  This is called sequentially
def animate(i):
    x = r[:,0,i]
    y = r[:,1,i]
    line.set_data(x, y)
    return line,

# call the animator.  blit=True means only re-draw the parts that have changed.
anim = animation.FuncAnimation(fig, animate, init_func=init,
                               frames=Timesteps, interval=20, blit=True)


anim.save('basic_animation.mp4', fps=30, extra_args=['-vcodec', 'libx264'])

#plt.show()


    
    