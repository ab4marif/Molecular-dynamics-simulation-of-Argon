import numpy as np
from matplotlib import pyplot as plt
from matplotlib import animation




def createCoordinate(Numberparticles, Dimension):
    return np.random.random((Numberparticles,Dimension))*L

def createVelocity(Numberparticles, Dimension):
    return np.random.random((Numberparticles,Dimension))

def calculateDistance(r):
    N = r.shape[0]
    D = r.shape[1]
        
    bigR = np.broadcast_to(r, (N, N, D))
    bigRT = np.transpose(bigR, (1, 0, 2))
    
    deltaR = bigR - bigRT
    
    # minimal image implementation
    deltaR = (deltaR + L/2)%L - L/2
    
    return deltaR

def calculateForce(r, eps, sigma):
    deltaR = calculateDistance(r)
    
    normR = np.linalg.norm(deltaR, axis = 2, keepdims = True)
    mask = np.eye(N, dtype = bool)
    normR[mask,:] = 1
    
    
    deltaU = 4*eps*(6*sigma**6/normR**8 - 12*sigma**12/normR**14)*deltaR
    F = -np.sum(deltaU, axis = 1 )
    
    return F

def eulerMethod(r, v):
    F = calculateForce(r, eps, sigma)
    v = v + 1/mass*F*dt
    r = r + v*dt
    
    # boundary
    r = r%L
    return r, v



dt = 3e-11
eps = 119.8*1.38*10**-23
sigma = 3.405E-10
mass = 6.6E-26 
N = 5
D = 2
L = 2e-9
Timesteps = 100 #timesteps

r = np.zeros((N, D, Timesteps))
r[:,:,0] = createCoordinate(N, D)
v = createVelocity(N,D)*0
F = calculateForce(r[:,:,0], eps, sigma)


for i in range(1,Timesteps):
    r[:,:,i], v = eulerMethod(r[:,:,i-1] , v)
    
plt.plot(r[0,0,:], r[0,1,:], 'ro')
plt.plot(r[1,0,:], r[1,1,:], 'bo')



##################################################################################################################
############################ Animation ###########################################################################


# First set up the figure, the axis, and the plot element we want to animate
fig = plt.figure()
ax = plt.axes(xlim=(0, L), ylim=(0, L))
line, = ax.plot([], [], 'o', lw=2)

# initialization function: plot the background of each frame
def init():
    line.set_data([], [])
    return line,

# animation function.  This is called sequentially
def animate(i):
    x = r[:,0,i]
    y = r[:,1,i]
    line.set_data(x, y)
    return line,

# call the animator.  blit=True means only re-draw the parts that have changed.
anim = animation.FuncAnimation(fig, animate, init_func=init,
                               frames=Timesteps, interval=20, blit=True)


anim.save('basic_animation.mp4', fps=30, extra_args=['-vcodec', 'libx264'])

#plt.show()





def LJpotentialEnergy(x, y, eps, sigma):
    r = np.sqrt(x**2 + y**2) #distance r to the origin
    ba, bb = np.meshgrid(r,r)
    bt = bb.T
    rmatrix = np.abs(bb-bt) # distance matrix
    np.fill_diagonal(rmatrix,1)

    potentialmatrix = 4*eps*(sigma**12/rmatrix**12 - sigma**6/rmatrix**6 )
    np.fill_diagonal(potentialmatrix,0)

    return np.sum(potentialmatrix)

def kineticenergy(vx, vy, mass):
    v = np.sqrt(vx**2 + vy**2)
    E = 0.5*mass*v**2

    return np.sum(E)

def totalenergy(x, y, eps, sigma, vx, vy, mass):
    return kineticenergy(vx, vy, mass) + LJpotentialEnergy(x, y, eps, sigma)


    
# constansts
eps = 119.8*1.38*10**-23
sigma = 3.405E-10
mass = 6.6E-26
dt = 0.01
N = 2 #number of particles
Nt = 10 #number of time steps
L = 1 # length box

# initialazing the positions and the velocity of each particle and storing it in a vector.
x = np.random.random(N) 
y = np.random.random(N)
vx = np.random.random(N)
vy = np.random.random(N)

# looping over the amount of time steps we want to take

for time in range(Nt):
    # first calculating the force
    Fx, Fy = calcforce(x , y, N, eps, sigma)
    # using the force to get new positions and velocity 
    x, y, vx, vy = euler(x, y, vx, vy, Fx, Fy)
    
    plt.plot(x,y,'ro')

print('The total energy of the system is: ',totalenergy(x, y, eps, sigma, vx, vy, mass))
    
    