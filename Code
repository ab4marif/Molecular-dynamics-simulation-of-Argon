import numpy as np
import matplotlib.pyplot as plt


def calcforce(x , y, N, eps, sigma):
    """ 
    This function calculates the force on a particle due to the Lennard Jones potential.

    INPUT:
            it takes as input the coordinates of the particle,
            the number of particles and the constants epsilon and sigma.

    OUTPUT: 
            The force in the x and Y direction Fx, Fy


    """
    
    # Create a distance matrix for all particles
    
    r = np.sqrt(x**2 + y**2) #distance r to the origin
    ba, bb = np.meshgrid(r,r)
    bt = bb.T
    rmatrix = np.abs(bb-bt) # distance matrix

    # from the distance matrix calculate the derivative potential in the x and y direction to calculate the force in both directions
    
    np.fill_diagonal(rmatrix,1) # fill the diagonal with 1 to avoid division by zero
    delumatrix_x = 4*eps*x*(6*sigma**6/rmatrix**8 - 12*sigma**12/rmatrix**14 )
    delumatrix_y = 4*eps*y*(6*sigma**6/rmatrix**8 - 12*sigma**12/rmatrix**14 )
    np.fill_diagonal(delumatrix_x,0) # make the diagonal zero again
    np.fill_diagonal(delumatrix_y,0)
    
    # create an empty vector with size N and fill the vector with the sum of the derivative potential matrix for a resulting force 
    Fx = np.zeros(N)
    Fy = np.zeros(N)
    for i in range(N):
        Fx[i:] = -np.sum(delumatrix_x[i])
        Fy[i:] = -np.sum(delumatrix_y[i])

    return Fx, Fy

def euler(x, y, vx, vy, Fx, Fy):
    """ 
    This function implements the euler method.

    INPUT:
            it takes as input the coordinates of the particle,
            velocity and force of the particle

    OUTPUT: 
            New coordinates and velocity due to the force, x, y, vx, vy

    """
    vx = vx + 1/mass*Fx*dt
    vy = vy + 1/mass*Fy*dt

    x = x + vx*dt
    y = y + vy*dt
    
    #boundary conditions
    x = x%L
    y = y%L
    return x, y, vx, vy
    

def LJpotentialEnergy(x, y, eps, sigma):
    r = np.sqrt(x**2 + y**2) #distance r to the origin
    ba, bb = np.meshgrid(r,r)
    bt = bb.T
    rmatrix = np.abs(bb-bt) # distance matrix
    np.fill_diagonal(rmatrix,1)

    potentialmatrix = 4*eps*(sigma**12/rmatrix**12 - sigma**6/rmatrix**6 )
    np.fill_diagonal(potentialmatrix,0)

    return np.sum(potentialmatrix)

def kineticenergy(vx, vy, mass):
    v = np.sqrt(vx**2 + vy**2)
    E = 0.5*mass*v**2

    return np.sum(E)

def totalenergy(x, y, eps, sigma, vx, vy, mass):
    return kineticenergy(vx, vy, mass) + LJpotentialEnergy(x, y, eps, sigma)


    
# constansts
eps = 119.8*1.38*10**-23
sigma = 3.405E-10
mass = 6.6E-26
dt = 0.01
N = 2 #number of particles
Nt = 10 #number of time steps
L = 1 # length box

# initialazing the positions and the velocity of each particle and storing it in a vector.
x = np.random.random(N) 
y = np.random.random(N)
vx = np.random.random(N)
vy = np.random.random(N)

# looping over the amount of time steps we want to take

for time in range(Nt):
    # first calculating the force
    Fx, Fy = calcforce(x , y, N, eps, sigma)
    # using the force to get new positions and velocity 
    x, y, vx, vy = euler(x, y, vx, vy, Fx, Fy)
    
    plt.plot(x,y,'ro')

print('The total energy of the system is: ',totalenergy(x, y, eps, sigma, vx, vy, mass))
    
    